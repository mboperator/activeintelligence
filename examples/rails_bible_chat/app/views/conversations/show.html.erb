<div style="margin-bottom: 20px;">
  <a href="<%= root_path %>" style="color: #007bff; text-decoration: none;">&larr; Back to Conversations</a>
  <h2 style="margin-top: 10px;">Conversation #<%= @conversation.id %></h2>
  <p style="color: #666; font-size: 14px;">Chat with the Bible Study Assistant</p>
</div>

<div class="chat-container">
  <div class="messages" id="messages">
    <% @messages.select{ |m| m.content.present? || m.role == 'tool' }.each do |message| %>
      <div class="message <%= message.role %>">
        <div class="message-role"><%= message.role %></div>
        <div class="message-content">
          <% if message.role == 'tool' %>
            <strong>ðŸ”§ Tool: <%= message.tool_name %></strong><br>
            <%= simple_format(message.content) %>
          <% else %>
            <%= simple_format(message.content) %>
          <% end %>
        </div>
      </div>
    <% end %>

    <% if @messages.empty? %>
      <div style="text-align: center; padding: 40px; color: #666;">
        <h3>Welcome to Bible Study Chat!</h3>
        <p style="margin-top: 10px;">Ask me anything about the Bible. I can look up specific verses and help you understand their meaning.</p>
        <p style="margin-top: 10px; font-size: 14px;">
          Try asking: "Can you show me John 3:16?" or "What does Psalm 23 say?"
        </p>
      </div>
    <% end %>
  </div>

  <div class="input-area">
    <form class="input-form" id="message-form">
      <input
        type="text"
        id="message-input"
        placeholder="Ask about Bible verses, passages, or themes..."
        autocomplete="off"
      />
      <button type="submit" id="send-button">Send</button>
    </form>
  </div>
</div>

<script>
  const conversationId = <%= @conversation.id %>;
  const messagesContainer = document.getElementById('messages');
  const messageForm = document.getElementById('message-form');
  const messageInput = document.getElementById('message-input');
  const sendButton = document.getElementById('send-button');

  let isProcessing = false;

  // Auto-scroll to bottom
  function scrollToBottom() {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  // Add message to UI
  function addMessage(role, content, toolName = null) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}`;

    const roleLabel = document.createElement('div');
    roleLabel.className = 'message-role';
    roleLabel.textContent = role;

    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';

    if (role === 'tool' && toolName) {
      contentDiv.innerHTML = `<strong>ðŸ”§ Tool: ${toolName}</strong><br>${content}`;
    } else {
      contentDiv.textContent = content;
    }

    messageDiv.appendChild(roleLabel);
    messageDiv.appendChild(contentDiv);
    messagesContainer.appendChild(messageDiv);

    scrollToBottom();
    return contentDiv;
  }

  // Execute frontend tool
  async function executeFrontendTool(tool) {
    if (tool.tool_name === 'show_emoji') {
      // Display as a tool message (matching DB format)
      const toolDiv = document.createElement('div');
      toolDiv.className = 'message tool';

      const roleLabel = document.createElement('div');
      roleLabel.className = 'message-role';
      roleLabel.textContent = 'tool';

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.innerHTML = `<strong>ðŸ”§ Tool: ${tool.tool_name}</strong><br>`;

      // Display the emoji in the tool message
      const emojiSpan = document.createElement('span');
      const sizeMap = { small: '2em', medium: '4em', large: '6em' };
      emojiSpan.textContent = tool.parameters.emoji;
      emojiSpan.style.fontSize = sizeMap[tool.parameters.size || 'medium'];
      emojiSpan.style.display = 'block';
      emojiSpan.style.margin = '10px 0';

      contentDiv.appendChild(emojiSpan);

      if (tool.parameters.message) {
        const messageP = document.createElement('p');
        messageP.textContent = tool.parameters.message;
        contentDiv.appendChild(messageP);
      }

      // Add success indicator
      const successP = document.createElement('p');
      successP.textContent = `{"success":true,"emoji":"${tool.parameters.emoji}","displayed":true}`;
      successP.style.fontSize = '12px';
      successP.style.color = '#666';
      successP.style.marginTop = '10px';
      contentDiv.appendChild(successP);

      toolDiv.appendChild(roleLabel);
      toolDiv.appendChild(contentDiv);
      messagesContainer.appendChild(toolDiv);
      scrollToBottom();

      // Return success result
      return {
        tool_use_id: tool.tool_use_id,
        result: {
          success: true,
          emoji: tool.parameters.emoji,
          displayed: true
        }
      };
    }

    // Unknown tool - return error
    return {
      tool_use_id: tool.tool_use_id,
      result: {
        error: true,
        message: `Unknown frontend tool: ${tool.tool_name}`
      }
    };
  }

  // Continue conversation with tool results
  async function continueWithToolResults(toolResults, assistantContent) {
    try {
      const response = await fetch(`/conversations/${conversationId}/send_message_streaming`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream'
        },
        body: JSON.stringify({ tool_results: toolResults })
      });

      await processStreamingResponse(response, assistantContent);
    } catch (error) {
      console.error('Error continuing with tool results:', error);
      addMessage('assistant', 'Sorry, there was an error continuing the conversation.');
    }
  }

  // Process streaming response (extracted for reuse)
  async function processStreamingResponse(response, assistantContent) {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let currentEvent = null;

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');

      // Keep last line if incomplete (doesn't end with \n)
      if (!buffer.endsWith('\n')) {
        buffer = lines.pop();
      } else {
        buffer = '';
      }

      for (const line of lines) {
        // console.log(line); // Uncomment for debugging
        if (line.startsWith('event: ')) {
          currentEvent = line.substring(7);
          // console.log('Event:', currentEvent); // Uncomment for debugging
        } else if (line.startsWith('data: ')) {
          const data = line.substring(6);

          if (data === '[DONE]') {
            continue;
          }

          if (currentEvent === 'frontend_tool_request') {
            // Parse frontend tool request
            try {
              const toolRequest = JSON.parse(data);
              console.log('Frontend tool request:', toolRequest);

              // Execute all pending frontend tools
              const toolResults = [];
              for (const tool of toolRequest.pending_tools) {
                const result = await executeFrontendTool(tool);
                toolResults.push(result);
              }

              // Continue conversation with results
              await continueWithToolResults(toolResults, assistantContent);
            } catch (err) {
              console.error('Error processing frontend tool request:', err);
            }
            currentEvent = null;
          } else if (currentEvent === 'tool_result') {
            // Display backend tool result as a separate TOOL message
            try {
              const toolResult = JSON.parse(data);
              console.log('Backend tool result:', toolResult);

              const toolDiv = document.createElement('div');
              toolDiv.className = 'message tool';

              const roleLabel = document.createElement('div');
              roleLabel.className = 'message-role';
              roleLabel.textContent = 'tool';

              const contentDiv = document.createElement('div');
              contentDiv.className = 'message-content';
              contentDiv.innerHTML = `<strong>ðŸ”§ Tool: ${toolResult.tool_name}</strong><br>${toolResult.content}`;

              toolDiv.appendChild(roleLabel);
              toolDiv.appendChild(contentDiv);
              messagesContainer.appendChild(toolDiv);
              scrollToBottom();
            } catch (err) {
              console.error('Error processing tool result:', err);
            }
            currentEvent = null;
          } else {
            // Regular text data - append to assistant message
            assistantContent.textContent += data;
            scrollToBottom();
          }
        } else if (line === '') {
          // Empty line resets event type
          currentEvent = null;
        }
      }
    }
  }

  // Handle form submission with streaming
  messageForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    if (isProcessing || !messageInput.value.trim()) return;

    const message = messageInput.value.trim();
    messageInput.value = '';
    isProcessing = true;
    sendButton.disabled = true;
    sendButton.textContent = 'Sending...';

    // Add user message
    addMessage('user', message);

    try {
      // Create assistant message container for streaming
      const assistantContent = addMessage('assistant', '');

      // Use streaming endpoint
      const response = await fetch(`/conversations/${conversationId}/send_message_streaming?message=${encodeURIComponent(message)}`, {
        method: 'POST',
        headers: {
          'Accept': 'text/event-stream'
        }
      });

      await processStreamingResponse(response, assistantContent);
    } catch (error) {
      console.error('Error:', error);
      addMessage('assistant', 'Sorry, there was an error processing your message.');
    } finally {
      isProcessing = false;
      sendButton.disabled = false;
      sendButton.textContent = 'Send';
      messageInput.focus();
    }
  });

  // Initial scroll
  scrollToBottom();

  // Focus input on load
  messageInput.focus();
</script>
